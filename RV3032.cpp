/*
  Error Handling Schema:
    When performing multiple access operations within a function, to discern specifically which operation failed, 
    a composite error code is utilized. This composite code combines the sequence step of the function with the 
    respective error code generated by the underlying I2C library.

  Structure of Composite Error Code:
    - The tens place (and hundreds place if needed for more granularity) represent the step sequence within the 
      function where the error occurred.
    - The units place represents the error code returned by the I2C library operation.

  Example:
    If an error occurs at step 2 of the function, and the I2C library returns an error code 3, the composite error 
    code will be 23 (2*10 + 3).

  Deciphering Error Code:
    - Divide the composite error code by 10 (or 100 if more granularity is used) to find out the step in the function
      where the error occurred.
    - The remainder gives the specific I2C library error.
    - Refer to the I2C library documentation to interpret the I2C error codes.

  Note:
    - A return value of 0 denotes that the function executed successfully without any errors.
    - Each step and corresponding error should be clearly documented within the function to allow for accurate troubleshooting.
*/



#include <inttypes.h>
#if defined(__AVR__)
#include <avr/io.h>
#endif
#if ARDUINO >= 100
#include "Arduino.h"
#else
#include "WProgram.h"
#endif

#include "I2C.h"
#include "RV3032.h"

I2C i2cRTC;      // Important if you want to use the methods defined in the I2C class!!!

//-------------------- Constructor --------------------


RV3032::RV3032(void)
{
  // Initialize EEPROMbuffer to zero
    memset(EEPROMBuffer, 0, sizeof(EEPROMBuffer));
  
  return;
}


//-------------------- Public --------------------

// Prepares on the uC the I2C communication with the RV3032
//    · Input: void
//    · Output: void
void RV3032::begin()
{
  i2cRTC.begin();        //init i2cRTC lib
}


// Freezes RTCC time circuits
//    · Input: void
//    · Output: Return status code of the operation

uint8_t RV3032::stopRTCC(uint8_t RTCCaddress)
{
  uint8_t Control_2_copy = 0; 
  uint8_t errorCode = 0;
  
  errorCode = i2cRTC.read(RTCCaddress, Control_2, (uint8_t) 1);
  if(errorCode != 0)
  {
    return 10 + errorCode;
  }
  Control_2_copy = i2cRTC.receive();

  if( (Control_2_copy & STOP) != 0)   // If STOP bit is already set, skip
  {
    Control_2_copy |= STOP; // Set STOP bit
    errorCode = i2cRTC.write(RTCCaddress, Control_2, Control_2_copy);   // Make change effective on RTCC
    if(errorCode != 0)
    {
      return 20 + errorCode;
    }
  }
  return 0; // Success
}

// Resume RTCC time circuits
//    · Input: void
//    · Output: Return status code of the operation
uint8_t RV3032::restartRTCC (uint8_t RTCCaddress)
{
  uint8_t Control_2_copy = 0;
  uint8_t errorCode = 0;
  
  errorCode = i2cRTC.read(RTCCaddress, Control_2, (uint8_t) 1);
  if(errorCode != 0)
  {
    return 10 + errorCode;
  }
  Control_2_copy = i2cRTC.receive();

  if( (Control_2_copy & STOP) == 0)   // If STOP bit is already clear, skip
  {
    Control_2_copy &= ~STOP; // Clear STOP bit
    errorCode = i2cRTC.write(RTCCaddress, Control_2, Control_2_copy);   // Effectively resume RTCC time circuits
    {
      return 20 + errorCode;
    }
  }
  return 0; // Success
}

// Read content from one RTCC register
//    · Input:  RTCC address ; RTCC register to be read ; Pointer to the content of the RTCC register
//    · Output: Return status code of the operation

uint8_t RV3032::readRTCCRegister (uint8_t RTCCaddress, uint8_t RTCCregister, uint8_t *RTCCRegisterContent)
{
  uint8_t errorCode = 0;
  
  i2cRTC.read(RTCCaddress, RTCCregister, (uint8_t) 1);
  if(errorCode != 0)
  {
    return 10 + errorCode;
  }
  *RTCCRegisterContent = i2cRTC.receive();

  return 0; // Success
}

// Write RTCC register with data
//    · Input:  RTCC address ; Data
//    · Output: Return status code of the operation

uint8_t RV3032::writeRTCCRegister (uint8_t RTCCaddress, uint8_t RTCregister, uint8_t Data)
{
  uint8_t errorCode = 0;
  
  errorCode = i2cRTC.write(RTCCaddress, RTCregister, Data);
  if(errorCode != 0)
  {
    return 10 + errorCode;
  }
  
  return 0; // Success
}

// Clear a specific flag in a register
//    · Input:  RTCC address ; Register that contains the flag ; flag name (defined in RV3032.h)
//    · Output: Return status code of the operation

uint8_t RV3032::clearFlag (uint8_t RTCCaddress, uint8_t Register, uint8_t flag)
{
  uint8_t RegValue = 0;
  uint8_t errorCode = 0;
  
  errorCode = i2cRTC.read(RTCCaddress, Register, (uint8_t) 1);   // Store target register value prior to modification
  if(errorCode != 0)
  {
    return 10 + errorCode;
  }
  RegValue = i2cRTC.receive();

  errorCode = i2cRTC.write(RTCCaddress, Register, (uint8_t) (RegValue & flag));  // Clear flag
  if(errorCode != 0)
  {
    return 20 + errorCode;
  }
  return 0; // Success
}


// Set the RTC's date
//    · Input: RTCC address, Year, Month and Day
//    · Output: Return status code of the operation

uint8_t RV3032::setDate (uint8_t RTCCaddress, uint16_t Year, uint8_t Month, uint8_t Day)
{
  //Array to hold the 3 bytes that will be written to the register
  uint8_t writeBytes[3];
  uint8_t Control_2_copy = 0;
  uint8_t errorCode = 0;
  
  if(Year > 2000)
  {
    Year -= 2000;
  }
  
  // Freeze RTCC time circuits 
  errorCode = i2cRTC.read(RTCCaddress, Control_2, (uint8_t) 1);
  if(errorCode != 0)
  {
    return 10 + errorCode;
  }
  Control_2_copy = i2cRTC.receive();
  
  if( (Control_2_copy & STOP) != 0)   // If STOP bit is already set, skip
  {
    Control_2_copy |= STOP; // Set STOP bit
    errorCode = i2cRTC.write(RTCCaddress, Control_2, Control_2_copy);   // Make change effective on RTCC
    if(errorCode != 0)
    {
      return 20 + errorCode;
    }
  }
    
  writeBytes[0] = bin2bcd(Day); //MSB
  writeBytes[1] = bin2bcd(Month);
  writeBytes[2] = bin2bcd(Year);
  
  errorCode = i2cRTC.write(RTCCaddress, Date, writeBytes, 3);  // Update RTCC Date registers
  if(errorCode != 0)
  {
    return 30 + errorCode;
  }

  // Resume RTCC time circuits 
  errorCode = i2cRTC.read(RTCCaddress, Control_2, (uint8_t) 1);
  if(errorCode != 0)
  {
    return 40 + errorCode;
  }
  Control_2_copy = i2cRTC.receive();
  Control_2_copy &= ~STOP; // Clear STOP bit
  errorCode = i2cRTC.write(RTCCaddress, Control_2, Control_2_copy);   // Effectively resume RTCC time circuits
  if(errorCode != 0)
  {
    return 50 + errorCode;
  }
  return 0; // Success
}


// Set the RTC's time
//    · Input: RTCC address, Hour, minutes and seconds as usigned int
//    · Output: Return status code of the operation

uint8_t RV3032::setTime (uint8_t RTCCaddress, uint8_t Hour, uint8_t Min, uint8_t Sec)
{
  //Array to hold the 3 bytes that will be written to the register
  uint8_t writeBytes[3];
  uint8_t Control_2_copy = 0;
  uint8_t errorCode = 0;

  // Freeze RTCC time circuits 
  errorCode = i2cRTC.read(RTCCaddress, Control_2, (uint8_t) 1);
  if(errorCode != 0)
  {
    return 10 + errorCode;
  }
  Control_2_copy = i2cRTC.receive();
  
  if( (Control_2_copy & STOP) != 0)   // If STOP bit is already set, skip
  {
    Control_2_copy |= STOP; // Set STOP bit
    errorCode = i2cRTC.write(RTCCaddress, Control_2, Control_2_copy);   // Make change effective on RTCC
    if(errorCode != 0)
    {
      return 20 + errorCode;
    }
  }
  
  writeBytes[0] = bin2bcd(Sec); //MSB
  writeBytes[1] = bin2bcd(Min);
  writeBytes[2] = bin2bcd(Hour);

  errorCode = i2cRTC.write(RTCCaddress, Seconds, writeBytes, (uint8_t) 3);    // Update RTCC time registers
  if(errorCode != 0)
  {
    return 30 + errorCode;
  }

  // Resume RTCC time circuits 
  errorCode = i2cRTC.read(RTCCaddress, Control_2, (uint8_t) 1);
  if(errorCode != 0)
  {
    return 40 + errorCode;
  }
  Control_2_copy = i2cRTC.receive();
  Control_2_copy &= ~STOP; // Clear STOP bit
  errorCode = i2cRTC.write(RTCCaddress, Control_2, Control_2_copy);   // Effectively resume RTCC time circuits
  if(errorCode != 0)
  {
    return 50 + errorCode;
  }
  return 0; // Success
}


// Reads RTC's time and date
//    · Input: RTCC address, address to time structure defined in RV3032 class
//    · Output: Return status code of the operation

uint8_t RV3032::getTimeDate (uint8_t RTCCaddress, time *_time)
{
  uint8_t errorCode = 0;
  
  errorCode = i2cRTC.read(RTCCaddress, Seconds, (uint8_t) 7);
  if(errorCode != 0)
  {
    return 10 + errorCode;
  }
  _time->Sec      = bcd2bin(i2cRTC.receive() & 0x7F);
  _time->Min      = bcd2bin(i2cRTC.receive() & 0x7F);
  _time->Hour     = bcd2bin(i2cRTC.receive() & 0x3F);       // 24 hour mode
  _time->Weekday  = bcd2bin(i2cRTC.receive() & 0x07);       // Day of the week
  _time->Day      = bcd2bin(i2cRTC.receive() & 0x3F);       // Day of the month
  _time->Month    = bcd2bin(i2cRTC.receive() & 0x1F);
  _time->Year     = bcd2bin(i2cRTC.receive()) + 2000;
  
  return 0; // Success
}



// Setup Timer to countdown 'Nsec' and activate #INT_1 
// interrupt when the timer expires
//    · Input: RTCC address, Number of seconds to countdown
//    · Output: Return status code of the operation

uint8_t RV3032::setTimerNsec(uint8_t RTCCaddress, uint16_t Nsec)
{
  uint8_t Control_1_copy = 0, Control_2_copy = 0, Status_copy = 0;
  uint8_t errorCode = 0;

  // 1. Initialize bits TE, TIE and TF to 0. In that order, to 
  //    prevent inadvertent interrupts on #INT pin
  errorCode = i2cRTC.read(RTCCaddress, Control_1, (uint8_t) 1);
  if(errorCode != 0)
  {
    return 10 + errorCode;
  }
  Control_1_copy = i2cRTC.receive();
  Control_1_copy &= ~TE;  // Clear TE bit
  errorCode = i2cRTC.write(RTCCaddress, Control_1, Control_1_copy);
  if(errorCode != 0)
  {
    return 20 + errorCode;
  }

  errorCode = i2cRTC.read(RTCCaddress, Control_2, (uint8_t) 1);
  if(errorCode != 0)
  {
    return 30 + errorCode;
  }
  Control_2_copy = i2cRTC.receive();
  Control_2_copy &= ~TIE;  // Clear TIE bit
  errorCode = i2cRTC.write(RTCCaddress, Control_2, Control_2_copy);
  if(errorCode != 0)
  {
    return 40 + errorCode;
  }
    
  errorCode = i2cRTC.read(RTCCaddress, Status, (uint8_t) 1);
  if(errorCode != 0)
  {
    return 50 + errorCode;
  }
  Status_copy = i2cRTC.receive();
  Status_copy &= ~TF;  // Clear TF bit
  errorCode = i2cRTC.write(RTCCaddress, Status, Status_copy);
  if(errorCode != 0)
  {
    return 60 + errorCode;
  }

  // 2. Select Timer Clock Frequency and write value in the TD field
  Control_1_copy &= 0b11111100;     // Erase TD old value
  Control_1_copy |= 0b00000010;     // Set TD[1:0] = 10 (1s)

  // 3. Write Counter value to Timer Value 0 and Timer Value 1 registers
  errorCode = i2cRTC.write(RTCCaddress, TimerValue_0, (uint8_t) Nsec);
  if(errorCode != 0)
  {
    return 70 + errorCode;
  }
  errorCode = i2cRTC.write(RTCCaddress, TimerValue_1, (uint8_t) ((Nsec & 0b0000111100000000) >> 8));
  if(errorCode != 0)
  {
    return 80 + errorCode;
  }

  // 4. Set the TIE bit to 1 to get a hardware interrupt on #INT pin
  Control_2_copy |= TIE;       // Set TIE bit
  errorCode = i2cRTC.write(RTCCaddress, Control_2, Control_2_copy);
  if(errorCode != 0)
  {
    return 90 + errorCode;
  }

  // 5. Set the TE bit from 0 to 1 to start the Periodic Countdown Timer
  Control_1_copy |= TE;       // Set TE bit
  errorCode = i2cRTC.write(RTCCaddress, Control_1, Control_1_copy);
  if(errorCode != 0)
  {
    return 100 + errorCode;
  }

  return 0; // Success
}

// Update Timer countdown value in Seconds
//    · Input: RTCC address, Number of secons to countdown
//    · Output: Return status code of the operation
uint8_t RV3032::updateTimerNsec (uint8_t RTCCaddress, uint16_t Nsec)
{
  uint8_t Control_1_copy = 0;
  uint8_t errorCode = 0;
  
  // 1. Set Timer Clock Frequency to count seconds
  errorCode = i2cRTC.read(RTCCaddress, Control_1, (uint8_t) 1);
  if(errorCode != 0)
  {
    return 10 + errorCode;
  }
  Control_1_copy = i2cRTC.receive();
  Control_1_copy &= 0b11111100;     // Erase TD old value
  Control_1_copy |= 0b00000010;     // Set TD[1:0] = 10 (1s)
  errorCode = i2cRTC.write(RTCCaddress, Control_1, Control_1_copy);   // Make change effective
  if(errorCode != 0)
  {
    return 20 + errorCode;
  }
  
  // 2. Write new Timer value to Timer Value 0 and Timer Value 1 registers
  errorCode = i2cRTC.write(RTCCaddress, TimerValue_0, (uint8_t) Nsec);
  if(errorCode != 0)
  {
    return 30 + errorCode;
  }
  errorCode = i2cRTC.write(RTCCaddress, TimerValue_1, (uint8_t) ((Nsec & 0b0000111100000000) >> 8));
  if(errorCode != 0)
  {
    return 40 + errorCode;
  }

  return 0; // Success
}



// Countdown 'Nmin' and activate #INT_1 interrupt when it expires
//    · Input: RTCC address, Number of minutes to countdown
//    · Output: Return status code of the operation

uint8_t RV3032::setTimerNmin(uint8_t RTCCaddress, uint16_t Nmin)
{
  uint8_t Control_1_copy = 0, Control_2_copy = 0, Status_copy = 0;
  uint8_t errorCode = 0;

  // 1. Initialize bits TE, TIE and TF to 0. In that order, to 
  //    prevent inadvertent interrupts on #INT pin
  errorCode = i2cRTC.read(RTCCaddress, Control_1, (uint8_t) 1);
  if(errorCode != 0)
  {
    return 10 + errorCode;
  }
  Control_1_copy = i2cRTC.receive();
  Control_1_copy &= ~TE;  // Clear TE bit
  errorCode = i2cRTC.write(RTCCaddress, Control_1, Control_1_copy);
  if(errorCode != 0)
  {
    return 20 + errorCode;
  }

  errorCode = i2cRTC.read(RTCCaddress, Control_2, (uint8_t) 1);
  if(errorCode != 0)
  {
    return 30 + errorCode;
  }
  Control_2_copy = i2cRTC.receive();
  Control_2_copy &= ~TIE;  // Clear TIE bit
  errorCode = i2cRTC.write(RTCCaddress, Control_2, Control_2_copy);
  if(errorCode != 0)
  {
    return 40 + errorCode;
  }
    
  errorCode = i2cRTC.read(RTCCaddress, Status, (uint8_t) 1);
  if(errorCode != 0)
  {
    return 50 + errorCode;
  }
  Status_copy = i2cRTC.receive();
  Status_copy &= ~TF;  // Clear TF bit
  errorCode = i2cRTC.write(RTCCaddress, Status, Status_copy);
  if(errorCode != 0)
  {
    return 60 + errorCode;
  }

  // 2. Select Timer Clock Frequency for MINUTES and write value in the TD field
  Control_1_copy &= 0b11111100;      // Erase TD old value
  Control_1_copy |= 0b00000011;      // Set TD[1:0] = 11 (1 minute)
    
  // 3. Write Counter value to Timer Value 0 and Timer Value 1 registers
  errorCode = i2cRTC.write(RTCCaddress, TimerValue_0, (uint8_t) Nmin);  // Write 8 LSBs into Timer Value 0
  if(errorCode != 0)
  {
    return 70 + errorCode;
  }
  errorCode = i2cRTC.write(RTCCaddress, TimerValue_1, (uint8_t) ((Nmin & 0b0000111100000000) >> 8));  // Write bits 9 to 12 into 4 LSBs of Timer Value 1
  if(errorCode != 0)
  {
    return 80 + errorCode;
  }

  // 4. Set the TIE bit to 1 to get a hardware interrupt on #INT pin
  Control_2_copy |= TIE;       // Set TIE bit
  errorCode = i2cRTC.write(RTCCaddress, Control_2, Control_2_copy);
  if(errorCode != 0)
  {
    return 90 + errorCode;
  }

  // 5. Set the TE bit from 0 to 1 to start the Periodic Countdown Timer
  Control_1_copy |= TE;       // Set TE bit
  errorCode = i2cRTC.write(RTCCaddress, Control_1, Control_1_copy);
  if(errorCode != 0)
  {
    return 100 + errorCode;
  }

  return 0; // Success
}


// Update Timer countdown value in Minutes
//    · Input: RTCC address, Number of minutes to countdown
//    · Output: Return status code of the operation

uint8_t RV3032::updateTimerNmin (uint8_t RTCCaddress, uint16_t Nmin)
{
  uint8_t Control_1_copy = 0;
  uint8_t errorCode = 0;
  
  // 1. 
  errorCode = i2cRTC.read(RTCCaddress, Control_1, (uint8_t) 1);
  if(errorCode != 0)
  {
    return 10 + errorCode;
  }
  Control_1_copy = i2cRTC.receive();
  
  // 2. Set Timer Clock Frequency to count seconds
  Control_1_copy &= 0b11111100;     // Erase TD old value
  Control_1_copy |= 0b00000011;      // Set TD[1:0] = 11 (1 minute)
  errorCode = i2cRTC.write(RTCCaddress, Control_1, Control_1_copy);   // Make change effective
  if(errorCode != 0)
  {
    return 20 + errorCode;
  }
  
  // 3. Write new Timer value to Timer Value 0 and Timer Value 1 registers
  errorCode = i2cRTC.write(RTCCaddress, TimerValue_0, (uint8_t) Nmin);
  if(errorCode != 0)
  {
    return 30 + errorCode;
  }
  errorCode = i2cRTC.write(RTCCaddress, TimerValue_1, (uint8_t) ((Nmin & 0b0000111100000000) >> 8));
  if(errorCode != 0)
  {
    return 40 + errorCode;
  }
}


// Set an alarm at a specific hour and minute
//    · Input:  The hour and minute at which the alarm should be active
//    · Output: Return status code of the operation

uint8_t RV3032::setAlarm(uint8_t RTCCaddress, uint8_t Hour, uint8_t Minute) 
{
  uint8_t Status_copy, Control_2_copy;
  uint8_t errorCode = 0;
    
  // Safeguards
  if(Minute > 59) 
  {
      return 201; // Invalid minute value
  }

  if(Hour > 23) 
  {
      return 202; // Invalid hour value
  }

  // 1. Initialize bits AIE and AF to 0
  errorCode = i2cRTC.read(RTCCaddress, Control_2, 1);
  if(errorCode != 0)
  {
    return 10 + errorCode;
  }
  Control_2_copy = i2cRTC.receive();
  Control_2_copy &= ~AIE; // Clear AIE bit
  errorCode = i2cRTC.write(RTCCaddress, Control_2, Control_2_copy);
  if(errorCode != 0)
  {
    return 20 + errorCode;
  }
    
  errorCode = i2cRTC.read(RTCCaddress, Status, 1);
  if(errorCode != 0)
  {
    return 30 + errorCode;
  }
  Status_copy = i2cRTC.receive();
  Status_copy &= ~AF; // Clear AF flag
  errorCode = i2cRTC.write(RTCCaddress, Status, Status_copy);
  if(errorCode != 0)
  {
    return 40 + errorCode;
  }

  // Convert Hour and Minute to BCD
  Hour = bin2bcd(Hour);
  Minute = bin2bcd(Minute);

  // 2. Preset alarm values in registers 08h to 0Ah (including proper values for AE_M, AE_H and AE_D bits)
  errorCode = i2cRTC.write(RTCCaddress, DateAlarm, (uint8_t) (0b10000000));  // Disable "date alarm" (AE_D = 1)
  if(errorCode != 0)
  {
    return 50 + errorCode;
  }
  errorCode = i2cRTC.write(RTCCaddress, HoursAlarm, (uint8_t) (Hour & 0b01111111)); // Preset "Hour" and Enable "hour alarm" (AE_H = 0)
  if(errorCode != 0)
  {
    return 60 + errorCode;
  }
  errorCode = i2cRTC.write(RTCCaddress, MinutesAlarm, (uint8_t) (Minute & 0b01111111)); // Preset "Minute" and Enable "minute alarm" (AE_M = 0)
  if(errorCode != 0)
  {
    return 70 + errorCode;
  }

  // 3. Set the AIE bit to 1 to get a hardware interrupt on #INT pin
  Control_2_copy |= AIE; // Set AIE bit
  errorCode = i2cRTC.write(RTCCaddress, Control_2, Control_2_copy);
  if(errorCode != 0)
  {
    return 80 + errorCode;
  }

  return 0; // Success
}


// Stop and Reset alarm
//    · Input:  RTCC address
//    · Output: Return status code of the operation

uint8_t RV3032::resetAlarm (uint8_t RTCCaddress)
{
  //Array to hold the 3 bytes that will be written to the register
  uint8_t writeBytes[3], Control_2_copy = 0, Status_copy = 0;
  int8_t errorCode = 0;
  
  // 1. Initialize bits AIE and AF to 0
  errorCode = i2cRTC.read(RTCCaddress, Control_2, 1);
  if(errorCode != 0)
  {
    return 10 + errorCode;
  }
  Control_2_copy = i2cRTC.receive();
  Control_2_copy &= ~AIE; // Clear AIE bit
  errorCode = i2cRTC.write(RTCCaddress, Control_2, Control_2_copy);
  if(errorCode != 0)
  {
    return 20 + errorCode;
  }
    
  errorCode = i2cRTC.read(RTCCaddress, Status, 1);
  if(errorCode != 0)
  {
    return 30 + errorCode;
  }
  Status_copy = i2cRTC.receive();
  Status_copy &= ~AF; // Clear AF flag
  errorCode = i2cRTC.write(RTCCaddress, Status, Status_copy);
  if(errorCode != 0)
  {
    return 40 + errorCode;
  }
  
  // Reset Alarm registers
  writeBytes[0] = 0b10000000; //MSB
  writeBytes[1] = 0b10000000;
  writeBytes[2] = 0b10000000;

  errorCode = i2cRTC.write(RTCCaddress, MinutesAlarm, writeBytes, (uint8_t) 3);    // Update RTCC time registers starting from "MinutesAlarm"
  if(errorCode != 0)
  {
    return 50 + errorCode;
  }

  return 0; // Success
}


// Stop and Reset Timer
//    · Input:  RTCC address
//    · Output: Return status code of the operation

uint8_t RV3032::resetTimer (uint8_t RTCCaddress)
{
  uint8_t Control_1_copy = 0, Control_2_copy = 0, Status_copy = 0;
  uint8_t writeBytes[2];
  int8_t errorCode = 0;

  // 1. Initialize bits TE, TIE and TF to 0. In that order, to 
  //    prevent inadvertent interrupts on #INT pin
  errorCode = i2cRTC.read(RTCCaddress, Control_1, (uint8_t) 1);
  if(errorCode != 0)
  {
    return 10 + errorCode;
  }
  Control_1_copy = i2cRTC.receive();
  Control_1_copy &= ~TE;  // Clear TE bit
  errorCode = i2cRTC.write(RTCCaddress, Control_1, Control_1_copy);
  if(errorCode != 0)
  {
    return 20 + errorCode;
  }

  errorCode = i2cRTC.read(RTCCaddress, Control_2, (uint8_t) 1);
  if(errorCode != 0)
  {
    return 30 + errorCode;
  }
  Control_2_copy = i2cRTC.receive();
  Control_2_copy &= ~TIE;  // Clear TIE bit
  errorCode = i2cRTC.write(RTCCaddress, Control_2, Control_2_copy);
  if(errorCode != 0)
  {
    return 40 + errorCode;
  }
    
  errorCode = i2cRTC.read(RTCCaddress, Status, (uint8_t) 1);
  if(errorCode != 0)
  {
    return 50 + errorCode;
  }
  Status_copy = i2cRTC.receive();
  Status_copy &= ~TF;  // Clear TF bit
  errorCode = i2cRTC.write(RTCCaddress, Status, Status_copy);
  if(errorCode != 0)
  {
    return 60 + errorCode;
  }

  // Reset Counter registers
  writeBytes[0] = 0b10000000; //MSB
  writeBytes[1] = 0b10000000;

  errorCode = i2cRTC.write(RTCCaddress, TimerValue_0, writeBytes, (uint8_t) 2);    // Update RTCC time registers starting from "TimerValue_0"
  if(errorCode != 0)
  {
    return 70 + errorCode;
  }

  return 0; // Success
}


// Updates "local RAM-mirrored-EEPROM" with an specific value
//    · Input:  
//         - registerAddress: The address of the "local RAM-mirrored-EEPROM" register
//         - RegisterName:    Name of the register to be updated
//         - Value:           Value that should be written to the "local RAM-mirrored-EEPROM"
//    · Output: Returns a status byte indicating the result of the operation

bool RV3032::SetLocalEEPROMmirrorRegister(uint8_t RegisterName, uint8_t Value)
{
  EEPROMBuffer[RegisterName - EEPROM_PMU] = Value;
  return 0;
}

// Writes the "RAM-mirrored-EEPROM" configuration to the EEPROM in a single bulk operation.
// It assumes all "local RAM-mirrored-EEPROM" registers have been configured previously
//    · Input:  None
//    · Output: True if the bulk write operation was successful, otherwise False

uint8_t RV3032::WriteAllRAMmirrorToEEPROM(uint8_t RTCCaddress)
{
  uint8_t Control_1_copy = 0, Temperature_LSBs_copy = 0;
  int8_t errorCode = 0;
    
  // 1. Disable automatic refresh function (EERD = 1)
  errorCode = i2cRTC.read(RTCCaddress, Control_1, (uint8_t) 1);
  if(errorCode != 0)
  {
    return 10 + errorCode;
  }
  Control_1_copy = i2cRTC.receive();
  Control_1_copy |= EERD;  // Set EERD bit
  errorCode = i2cRTC.write(RTCCaddress, Control_1, Control_1_copy);
  if(errorCode != 0)
  {
    return 20 + errorCode;
  }  
  
  // 2. Check if last EEPROM transfer is finished (EEBusy = 0)
  errorCode = i2cRTC.read(RTCCaddress, Temperature_LSBs, (uint8_t) 1);
  if(errorCode != 0)
  {
    return 30 + errorCode;
  }
  Temperature_LSBs_copy = i2cRTC.receive();
  if( (Temperature_LSBs_copy & EEBusy) != 0)
  {
      return 210; // Error code for EEPROM busy
  }

  // 3. Transfer all eleven "local RAM-mirrored-EEPROM" registers to its  
  //    correspondent RTCC-"RAM-mirrored-EEPROM" register (Addresses: C0h to CAh)
  errorCode = i2cRTC.write(RTCCaddress, EEPROM_PMU, EEPROMBuffer, (uint8_t) 11);
  if(errorCode != 0)
  {
    return 40 + errorCode;
  }
  
  // 4. Write "RTCC-RAM-mirrored-EEPROM" to "RTCC-EEPROM" (EECMD = 11h)
  errorCode = i2cRTC.write(RTCCaddress, EE_Command, EEPROM_updateAll);
  if(errorCode != 0)
  {
    return 50 + errorCode;
  }
  Control_1_copy &= ~EERD;  // Clear EERD bit
  errorCode = i2cRTC.write(RTCCaddress, Control_1, Control_1_copy);
  if(errorCode != 0)
  {
    return 60 + errorCode;
  }
  return 0; // Success
}

//-------------------- Private --------------------

// Transforms a number from binary to BCD format
//    · Input:  Decimal number to be transformed  
//    · Output: BCD value of the decimal number

uint8_t RV3032::bin2bcd(uint8_t val)
{
  return val + 6 * (val / 10);
}


// Transforms a number from BCD to binary format
//    · Input:  BCD number to be transformed  
//    · Output: Decimal value of the BCD number

uint8_t RV3032::bcd2bin(uint8_t val)
{
  return val - 6 * (val >> 4);
}
